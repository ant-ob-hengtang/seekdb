/*
 * Copyright (c) 2025 OceanBase.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#define USING_LOG_PREFIX SHARE
#include "lib/oblog/ob_log_module.h"
#include "lib/allocator/ob_malloc.h"
#include "lib/thread/ob_thread_name.h"
#include "lib/utility/serialization.h"
#include "share/change_stream/ob_change_stream_fetcher.h"
#include "share/change_stream/ob_change_stream_mgr.h"
#include "share/ob_global_stat_proxy.h"
#include "storage/tx/ob_tx_log.h"
#include "storage/tx/ob_multi_data_source.h"
#include "storage/memtable/ob_memtable_mutator.h"
#include "share/inner_table/ob_inner_table_schema_constants.h"
#include "share/schema/ob_multi_version_schema_service.h"
#include "share/schema/ob_schema_service.h"
#include "logservice/ob_log_base_header.h"
#include "storage/ls/ob_ls.h"
#include "storage/tx_storage/ob_ls_service.h"
#include "storage/tx_storage/ob_ls_handle.h"
#include "logservice/ob_log_handler.h"
#include "logservice/palf/log_io_context.h"
#include "share/rc/ob_tenant_base.h"

namespace oceanbase
{
namespace share
{

ObCSFetcher::ObCSFetcher()
  : share::ObThreadPool(1),
    is_inited_(false),
    dispatcher_(nullptr),
    ls_id_(ObLSID::SYS_LS_ID),
    iter_(),
    current_lsn_(),
    current_scn_(),
    current_schema_version_(0),
    total_tx_committed_(0)
{
}

ObCSFetcher::~ObCSFetcher()
{
  destroy();
}

int ObCSFetcher::init(ObCSDispatcher *dispatcher)
{
  int ret = common::OB_SUCCESS;
  if (is_inited_) {
    ret = common::OB_INIT_TWICE;
  } else if (OB_ISNULL(dispatcher)) {
    ret = OB_INVALID_ARGUMENT;
    LOG_WARN("CSFetcher: dispatcher is null", KR(ret));
  } else if (OB_FAIL(tx_info_.create(CS_FETCHER_TX_INFO_BUCKET_CNT, "CSFetcherTx"))) {
    LOG_WARN("CSFetcher: fail to create tx_info map", KR(ret));
  } else if (FALSE_IT(ObThreadPool::set_run_wrapper(MTL_CTX()))) {
  } else if (OB_FAIL(ObThreadPool::init())) {
    LOG_WARN("CSFetcher: fail to init thread pool", KR(ret));
  } else {
    dispatcher_ = dispatcher;
    current_scn_.set_min();
    total_tx_committed_ = 0;
    is_inited_ = true;
  }
  return ret;
}

int ObCSFetcher::init_start_lsn_()
{
  int ret = common::OB_SUCCESS;
  int64_t persisted_min_dep_lsn = 0;
  if (OB_ISNULL(GCTX.sql_proxy_)) {
    ret = OB_ERR_UNEXPECTED;
    LOG_WARN("CSFetcher: sql_proxy is null", KR(ret));
  } else if (OB_FAIL(ObGlobalStatProxy::get_change_stream_min_dep_lsn(
                 *GCTX.sql_proxy_, MTL_ID(), false, persisted_min_dep_lsn))) {
    LOG_WARN("CSFetcher: fail to load change_stream_min_dep_lsn", KR(ret));
  } else {
    const palf::LSN start_lsn(persisted_min_dep_lsn);
    if (OB_FAIL(logservice::seek_log_iterator(ls_id_, start_lsn, iter_))) {
      LOG_WARN("CSFetcher: fail to seek_log_iterator by min_dep_lsn", KR(ret), K(start_lsn));
    } else {
      current_lsn_ = start_lsn;
      FLOG_INFO("CSFetcher: initialized from global_stat min_dep_lsn", K(start_lsn));
    }
  }
  if (OB_SUCC(ret)) {
    palf::LogIOContext io_ctx(MTL_ID(), ls_id_.id(), palf::LogIOUser::CDC);
    if (OB_FAIL(iter_.set_io_context(io_ctx))) {
      LOG_WARN("CSFetcher: fail to set_io_context", KR(ret));
    }
  }
  if (OB_SUCC(ret)) {
    if (OB_ISNULL(GCTX.schema_service_)) {
      ret = OB_ERR_UNEXPECTED;
      LOG_WARN("CSFetcher: schema_service is null", KR(ret));
    } else if (OB_FAIL(GCTX.schema_service_->get_tenant_refreshed_schema_version(
                   MTL_ID(), current_schema_version_))) {
      LOG_WARN("CSFetcher: fail to get_tenant_refreshed_schema_version", KR(ret));
    } else if (current_schema_version_ <= 0
               || !ObSchemaService::is_formal_version(current_schema_version_)) {
      ret = OB_SCHEMA_EAGAIN;
      LOG_WARN("CSFetcher: schema version not formal yet", KR(ret), K(current_schema_version_));
    } else {
      FLOG_INFO("CSFetcher: schema version initialized", K(current_schema_version_));
    }
  }
  return ret;
}

int ObCSFetcher::start()
{
  int ret = common::OB_SUCCESS;
  if (!is_inited_) {
    ret = common::OB_NOT_INIT;
  } else if (OB_FAIL(ObThreadPool::start())) {
    LOG_WARN("CSFetcher: fail to start thread pool", KR(ret));
  }
  return ret;
}

void ObCSFetcher::stop()
{
  ObThreadPool::stop();
}

void ObCSFetcher::wait()
{
  ObThreadPool::wait();
}

void ObCSFetcher::destroy()
{
  if (is_inited_) {
    stop();
    wait();
    // Clean up any remaining in-flight transactions.
    for (common::hash::ObHashMap<int64_t, ObCSTxInfo *>::iterator it = tx_info_.begin();
         it != tx_info_.end(); ++it) {
      if (OB_NOT_NULL(it->second)) {
        it->second->destroy();
        OB_DELETE(ObCSTxInfo, "CSTxInfo", it->second);
      }
    }
    tx_info_.destroy();
    dispatcher_ = nullptr;
    current_lsn_.reset();
    current_scn_.reset();
    is_inited_ = false;
  }
}

void ObCSTxInfo::destroy()
{
  for (int64_t i = 0; i < redo_list_.count(); ++i) {
    if (redo_list_.at(i).redo_buf_ != nullptr) {
      common::ob_free(redo_list_.at(i).redo_buf_);
      redo_list_.at(i).redo_buf_ = nullptr;
    }
  }
  redo_list_.reset();
  reset();
}

// ---------------------------------------------------------------------------
// get_min_dep_lsn: if tx_info_ non-empty, return min(start_lsn); else return end_lsn.
// ---------------------------------------------------------------------------

palf::LSN ObCSFetcher::get_min_dep_lsn() const
{
  if (!tx_info_.empty()) {
    palf::LSN min_lsn;
    min_lsn.reset();
    for (common::hash::ObHashMap<int64_t, ObCSTxInfo *>::const_iterator it = tx_info_.begin();
         it != tx_info_.end(); ++it) {
      if (OB_NOT_NULL(it->second) && it->second->start_lsn_.is_valid()) {
        if (!min_lsn.is_valid() || it->second->start_lsn_ < min_lsn) {
          min_lsn = it->second->start_lsn_;
        }
      }
    }
    return min_lsn.is_valid() ? min_lsn : current_lsn_;
  }
  int ret = OB_SUCCESS;
  palf::LSN end_lsn;
  storage::ObLSHandle tmp_handle;
  storage::ObLS *ls = nullptr;
  logservice::ObLogHandler *log_handler = nullptr;
  if (OB_FAIL(MTL(storage::ObLSService*)->get_ls(ls_id_, tmp_handle, storage::ObLSGetMod::LOG_MOD))
      || OB_ISNULL(ls = tmp_handle.get_ls())
      || OB_ISNULL(log_handler = ls->get_log_handler())
      || OB_FAIL(log_handler->get_end_lsn(end_lsn))) {
    LOG_WARN("CSFetcher: fail to get end_lsn for min_dep_lsn, fallback to current_lsn",
             KR(ret), K(ls_id_), K(current_lsn_));
    return current_lsn_;
  }
  return end_lsn;
}

void ObCSFetcher::try_advance_min_dep_lsn_()
{
  if (REACH_TIME_INTERVAL(CS_FETCHER_MIN_DEP_LSN_ADVANCE_INTERVAL_US) && OB_NOT_NULL(GCTX.sql_proxy_)) {
    const palf::LSN min_lsn = get_min_dep_lsn();
    int64_t affected = 0;
    if (min_lsn.is_valid()) {
      int ret = ObGlobalStatProxy::advance_change_stream_min_dep_lsn(
          *GCTX.sql_proxy_, MTL_ID(), static_cast<int64_t>(min_lsn.val_), affected);
      if (OB_FAIL(ret)) {
        LOG_WARN("CSFetcher: fail to advance_change_stream_min_dep_lsn", KR(ret), K(min_lsn));
      }
    }
  }
}

int ObCSFetcher::release_committed_tx(int64_t tx_id)
{
  int ret = common::OB_SUCCESS;
  ObCSTxInfo *tx = nullptr;
  if (OB_FAIL(tx_info_.erase_refactored(tx_id, &tx))) {
    LOG_WARN("CSFetcher: fail to release_committed_tx erase", KR(ret), K(tx_id));
  } else if (OB_NOT_NULL(tx)) {
    tx->destroy();
    OB_DELETE(ObCSTxInfo, "CSTxInfo", tx);
  }
  return ret;
}

// ---------------------------------------------------------------------------
// extract_ddl_schema_version_: scan DDL tx redo for __all_ddl_operation rows,
// extract schema_version from the rowkey (single int64 column).
// ---------------------------------------------------------------------------
int ObCSFetcher::extract_ddl_schema_version_(ObCSTxInfo *tx, int64_t &schema_version)
{
  int ret = common::OB_SUCCESS;
  schema_version = 0;
  if (OB_ISNULL(tx)) {
    ret = OB_INVALID_ARGUMENT;
    LOG_WARN("CSFetcher: extract_ddl_schema_version_ tx is null", KR(ret));
    return ret;
  }
  for (int64_t r = 0; OB_SUCC(ret) && r < tx->redo_list_.count(); ++r) {
    const char *buf = tx->redo_list_.at(r).redo_buf_;
    const int64_t buf_len = tx->redo_list_.at(r).redo_len_;
    int64_t pos = 0;
    memtable::ObMemtableMutatorMeta meta;
    if (OB_FAIL(meta.deserialize(buf, buf_len, pos))) {
      LOG_WARN("CSFetcher: fail to deserialize mutator meta", KR(ret), K(r));
      break;
    }
    while (OB_SUCC(ret) && pos < buf_len) {
      memtable::ObMutatorRowHeader row_header;
      if (OB_FAIL(row_header.deserialize(buf, buf_len, pos))) {
        LOG_WARN("CSFetcher: fail to deserialize row_header", KR(ret), K(pos));
        break;
      }
      const int64_t row_payload_start = pos;
      if (row_header.tablet_id_.id() == OB_ALL_DDL_OPERATION_TID) {
        memtable::ObMemtableMutatorRow mut_row;
        if (OB_FAIL(mut_row.deserialize(buf, buf_len, pos))) {
          LOG_WARN("CSFetcher: fail to deserialize mut_row", KR(ret));
          break;
        }
        if (mut_row.rowkey_.get_obj_cnt() >= 1) {
          int64_t sv = 0;
          if (OB_FAIL(mut_row.rowkey_.get_obj_ptr()[0].get_int(sv))) {
            LOG_WARN("CSFetcher: fail to get_int from rowkey", KR(ret));
          } else if (sv > schema_version) {
            schema_version = sv;
          }
        }
      } else {
        int32_t entry_len = 0;
        if (OB_FAIL(common::serialization::decode_i32(buf, buf_len, pos, &entry_len))) {
          LOG_WARN("CSFetcher: fail to decode entry_len", KR(ret), K(pos));
          break;
        }
        pos = row_payload_start + static_cast<int64_t>(entry_len);
        if (OB_UNLIKELY(pos < 0 || pos > buf_len)) {
          ret = common::OB_ERR_UNEXPECTED;
          LOG_WARN("CSFetcher: extract_ddl skip overflow", KR(ret), K(pos), K(buf_len));
        }
      }
    }
  }
  if (OB_SUCC(ret) && schema_version <= 0) {
    ret = OB_ENTRY_NOT_EXIST;
    LOG_DEBUG("CSFetcher: no __all_ddl_operation row found in DDL redo", KR(ret), K(tx->tx_id_));
  }
  return ret;
}

// ---------------------------------------------------------------------------
// get_or_create_tx_info_: shared by handle_redo_log_ and MDS DDL branch.
// ---------------------------------------------------------------------------
int ObCSFetcher::get_or_create_tx_info_(int64_t tid, const palf::LSN &lsn, ObCSTxInfo *&tx)
{
  int ret = OB_SUCCESS;
  tx = nullptr;
  if (OB_FAIL(tx_info_.get_refactored(tid, tx))) {
    if (OB_HASH_NOT_EXIST == ret) {
      ret = OB_SUCCESS;
      tx = OB_NEW(ObCSTxInfo, "CSTxInfo");
      if (OB_ISNULL(tx)) {
        ret = OB_ALLOCATE_MEMORY_FAILED;
        LOG_WARN("CSFetcher: fail to alloc ObCSTxInfo", KR(ret), K(tid));
      } else {
        tx->tx_id_ = tid;
        tx->start_lsn_ = lsn;
        if (OB_FAIL(tx_info_.set_refactored(tid, tx))) {
          LOG_WARN("CSFetcher: fail to insert tx_info", KR(ret), K(tid));
          tx->destroy();
          OB_DELETE(ObCSTxInfo, "CSTxInfo", tx);
          tx = nullptr;
        }
      }
    } else {
      LOG_WARN("CSFetcher: fail to get tx_info", KR(ret), K(tid));
    }
  }
  return ret;
}

// ---------------------------------------------------------------------------
// Transaction log handlers
// ---------------------------------------------------------------------------

int ObCSFetcher::handle_redo_log_(
    const transaction::ObTransID &tx_id,
    const char *mutator_buf,
    int64_t mutator_size,
    const palf::LSN &lsn)
{
  int ret = common::OB_SUCCESS;
  ObCSTxInfo *tx = nullptr;
  int64_t tid = tx_id.get_id();

  if (mutator_size <= 0 || mutator_size > CS_FETCHER_MAX_REDO_MUTATOR_SIZE) {
    ret = OB_INVALID_ARGUMENT;
    LOG_WARN("CSFetcher: invalid mutator_size", KR(ret), K(mutator_size), K(tid));
    return ret;
  }

  if (OB_FAIL(get_or_create_tx_info_(tid, lsn, tx))) {
    // error already logged
  } else if (OB_NOT_NULL(tx)) {
    char *buf = static_cast<char *>(common::ob_malloc(mutator_size, "CSRedoBuf"));
    if (OB_ISNULL(buf)) {
      ret = OB_ALLOCATE_MEMORY_FAILED;
      LOG_WARN("CSFetcher: fail to alloc redo buf", KR(ret), K(mutator_size));
    } else {
      MEMCPY(buf, mutator_buf, mutator_size);
      ObCSRedoRecord rec;
      rec.redo_buf_ = buf;
      rec.redo_len_ = mutator_size;
      if (OB_FAIL(tx->redo_list_.push_back(rec))) {
        LOG_WARN("CSFetcher: fail to push redo record", KR(ret), K(tid));
        common::ob_free(buf);
      }
    }
  }
  return ret;
}

int ObCSFetcher::handle_commit_log_(
    const transaction::ObTransID &tx_id,
    const SCN &commit_version)
{
  int ret = common::OB_SUCCESS;
  ObCSTxInfo *tx = nullptr;
  int64_t tid = tx_id.get_id();

  if (OB_FAIL(tx_info_.get_refactored(tid, tx))) {
    if (OB_HASH_NOT_EXIST == ret) {
      ret = OB_SUCCESS;
    } else {
      LOG_WARN("CSFetcher: fail to get tx_info on commit", KR(ret), K(tid));
    }
  } else if (OB_NOT_NULL(tx)) {
    tx->commit_version_ = commit_version.get_val_for_gts();
    if (tx->is_ddl_) {
      // DDL transaction: extract schema_version from __all_ddl_operation redo, then discard.
      int64_t ddl_schema_version = 0;
      int ddl_ret = extract_ddl_schema_version_(tx, ddl_schema_version);
      if (OB_SUCCESS == ddl_ret && ddl_schema_version > 0) {
        current_schema_version_ = ddl_schema_version;
        LOG_INFO("CSFetcher: DDL commit, schema_version advanced",
                 K(tid), K(ddl_schema_version), K(current_schema_version_));
      } else {
        LOG_DEBUG("CSFetcher: DDL commit, extract schema_version failed, unchanged",
                  KR(ddl_ret), K(tid), K(current_schema_version_));
      }
      tx_info_.erase_refactored(tid);
      tx->destroy();
      OB_DELETE(ObCSTxInfo, "CSTxInfo", tx);
      total_tx_committed_++;
    } else {
      // DML transaction: assign current schema_version and push to Dispatcher.
      // tx_info_ erase is deferred to release_committed_tx() called by Dispatcher
      // after Worker finishes processing the batch.
      tx->schema_version_ = current_schema_version_;
      if (OB_ISNULL(dispatcher_)) {
        ret = OB_ERR_UNEXPECTED;
        LOG_ERROR("CSFetcher: dispatcher_ is null", KR(ret));
      } else if (OB_FAIL(dispatcher_->push(tx))) {
        LOG_WARN("CSFetcher: fail to push tx to dispatcher, destroy tx to avoid leak", KR(ret), K(tid));
        (void)tx_info_.erase_refactored(tid);
        tx->destroy();
        OB_DELETE(ObCSTxInfo, "CSTxInfo", tx);
      } else {
        total_tx_committed_++;
      }
    }
  }
  return ret;
}

int ObCSFetcher::handle_abort_log_(const transaction::ObTransID &tx_id)
{
  int ret = common::OB_SUCCESS;
  ObCSTxInfo *tx = nullptr;
  int64_t tid = tx_id.get_id();

  if (OB_FAIL(tx_info_.erase_refactored(tid, &tx))) {
    if (OB_HASH_NOT_EXIST == ret) {
      ret = OB_SUCCESS; // Skip silently.
    } else {
      LOG_WARN("CSFetcher: fail to erase tx on abort", KR(ret), K(tid));
    }
  } else if (OB_NOT_NULL(tx)) {
    tx->destroy();
    OB_DELETE(ObCSTxInfo, "CSTxInfo", tx);
  }
  return ret;
}

int ObCSFetcher::handle_rollback_to_log_(
    const transaction::ObTransID &tx_id,
    const transaction::ObTxSEQ &from,
    const transaction::ObTxSEQ &to)
{
  int ret = common::OB_SUCCESS;
  ObCSTxInfo *tx = nullptr;
  int64_t tid = tx_id.get_id();

  if (OB_FAIL(tx_info_.get_refactored(tid, tx))) {
    if (OB_HASH_NOT_EXIST == ret) {
      ret = OB_SUCCESS; // Skip silently.
    } else {
      LOG_WARN("CSFetcher: fail to get tx_info on rollback_to", KR(ret), K(tid));
    }
  } else if (OB_NOT_NULL(tx)) {
    ObCSRollbackRange range(to, from);
    if (OB_FAIL(tx->rollback_list_.push_back(range))) {
      LOG_WARN("CSFetcher: fail to push rollback range", KR(ret), K(tid), K(from), K(to));
    }
  }
  return ret;
}

// ---------------------------------------------------------------------------
// Main Fetcher loop
// ---------------------------------------------------------------------------

void ObCSFetcher::run1()
{
  lib::set_thread_name("CSFetcher");

  int ret = OB_SUCCESS;
  bool iter_ready = false;

  // Retry init_start_lsn_ until success or stop.
  while (!has_set_stop() && !iter_ready) {
    if (OB_ISNULL(GCTX.sql_proxy_) || GCTX.in_bootstrap_ || GCTX.start_service_time_ <= 0) {
      usleep(CS_FETCHER_INIT_RETRY_SLEEP_US);
      continue;
    }
    ret = OB_SUCCESS;
    if (OB_SUCC(init_start_lsn_())) {
      iter_ready = true;
      FLOG_INFO("CSFetcher: iterator initialized, starting consumption",
                K(current_lsn_), K(current_scn_), K(ls_id_));
    } else {
      LOG_WARN("CSFetcher: init_start_lsn failed, retry", KR(ret));
      usleep(CS_FETCHER_INIT_FAIL_SLEEP_US);
    }
  }

  // Main log consumption loop.
  while (!has_set_stop()) {
    ret = OB_SUCCESS;

    try_advance_min_dep_lsn_();

    if (OB_FAIL(iter_.next())) {
      if (OB_ITER_END == ret) {
        usleep(CS_FETCHER_ITER_END_SLEEP_US);
        continue;
      }
      LOG_WARN("CSFetcher: fail to iter.next", KR(ret));
      usleep(CS_FETCHER_ITER_ERR_SLEEP_US);
      continue;
    }

    palf::LogEntry log_entry;
    palf::LSN lsn;
    if (OB_FAIL(iter_.get_entry(log_entry, lsn))) {
      LOG_WARN("CSFetcher: fail to get_entry", KR(ret));
      continue;
    }

    const char *buf = log_entry.get_data_buf();
    const int64_t buf_len = log_entry.get_data_len();
    const SCN scn = log_entry.get_scn();

    // Pre-check: only process transaction logs.
    logservice::ObLogBaseHeader base_header;
    int64_t header_pos = 0;
    if (OB_FAIL(base_header.deserialize(buf, buf_len, header_pos))) {
      LOG_WARN("CSFetcher: fail to deserialize ObLogBaseHeader", KR(ret), K(lsn));
      continue;
    }
    if (base_header.get_log_type() != logservice::ObLogBaseType::TRANS_SERVICE_LOG_BASE_TYPE) {
      // Not a transaction log â€” skip.
      current_lsn_ = lsn + log_entry.get_header_size() + buf_len;
      current_scn_ = scn;
      continue;
    }

    // Deserialize the transaction log block.
    transaction::ObTxLogBlock tx_log_block;
    if (OB_FAIL(tx_log_block.init_for_replay(buf, buf_len))) {
      LOG_WARN("CSFetcher: fail to init_for_replay", KR(ret), K(lsn));
      continue;
    }

    const transaction::ObTxLogBlockHeader &block_header = tx_log_block.get_header();
    // Log filter: only consume logs with has_async_index (tables with async vector index or DDL).
    if (!block_header.has_async_index()) {
      LOG_DEBUG("CSFetcher: skip log without has_async_index", K(lsn));
      current_lsn_ = lsn + log_entry.get_header_size() + buf_len;
      current_scn_ = scn;
      continue;
    }

    const transaction::ObTransID tx_id = block_header.get_tx_id();

    // Iterate transaction log entries within this block.
    transaction::ObTxLogHeader tx_header;
    while (OB_SUCC(ret)) {
      if (OB_FAIL(tx_log_block.get_next_log(tx_header))) {
        if (OB_ITER_END == ret) {
          ret = OB_SUCCESS;
          break;
        }
        LOG_WARN("CSFetcher: fail to get_next_log", KR(ret), K(lsn));
        break;
      }

      const transaction::ObTxLogType log_type = tx_header.get_tx_log_type();
      switch (log_type) {
        case transaction::ObTxLogType::TX_REDO_LOG: {
          transaction::ObTxRedoLogTempRef tmp_ref;
          transaction::ObTxRedoLog redo_log(tmp_ref);
          if (OB_FAIL(tx_log_block.deserialize_log_body(redo_log))) {
            LOG_WARN("CSFetcher: fail to deserialize redo", KR(ret), K(lsn));
          } else {
            const char *mutator_buf = redo_log.get_replay_mutator_buf();
            const int64_t mutator_size = redo_log.get_mutator_size();
            if (OB_NOT_NULL(mutator_buf) && mutator_size > 0) {
              if (OB_FAIL(handle_redo_log_(tx_id, mutator_buf, mutator_size, lsn))) {
                LOG_WARN("CSFetcher: fail to handle_redo_log", KR(ret), K(tx_id), K(lsn));
              }
            }
          }
          break;
        }
        case transaction::ObTxLogType::TX_MULTI_DATA_SOURCE_LOG: {
          transaction::ObTxMultiDataSourceLog mds_log;
          if (OB_FAIL(tx_log_block.deserialize_log_body(mds_log))) {
            LOG_WARN("CSFetcher: fail to deserialize MDS log", KR(ret), K(lsn));
          } else {
            const transaction::ObTxBufferNodeArray &mds_data = mds_log.get_data();
            for (int64_t i = 0; i < mds_data.count(); ++i) {
              if (mds_data.at(i).get_data_source_type()
                  == transaction::ObTxDataSourceType::DDL_TRANS) {
                ObCSTxInfo *tx = nullptr;
                int64_t tid = tx_id.get_id();
                if (OB_FAIL(get_or_create_tx_info_(tid, lsn, tx))) {
                  LOG_WARN("CSFetcher: fail to get tx_info on MDS DDL", KR(ret), K(tid));
                } else if (OB_NOT_NULL(tx)) {
                  tx->is_ddl_ = true;
                }
                break;
              }
            }
          }
          break;
        }
        case transaction::ObTxLogType::TX_COMMIT_LOG: {
          transaction::ObTxCommitLogTempRef tmp_ref;
          transaction::ObTxCommitLog commit_log(tmp_ref);
          if (OB_FAIL(tx_log_block.deserialize_log_body(commit_log))) {
            LOG_WARN("CSFetcher: fail to deserialize commit", KR(ret), K(lsn));
          } else {
            const int64_t cv_in_log = commit_log.get_commit_version().get_val_for_logservice();
            SCN commit_version;
            if (transaction::ObTransVersion::INVALID_TRANS_VERSION == cv_in_log) {
              commit_version = scn;
            } else {
              commit_version = commit_log.get_commit_version();
            }
            if (OB_FAIL(handle_commit_log_(tx_id, commit_version))) {
              LOG_WARN("CSFetcher: fail to handle_commit_log", KR(ret), K(tx_id), K(lsn));
            }
          }
          break;
        }
        case transaction::ObTxLogType::TX_ABORT_LOG: {
          transaction::ObTxAbortLogTempRef tmp_ref;
          transaction::ObTxAbortLog abort_log(tmp_ref);
          if (OB_FAIL(tx_log_block.deserialize_log_body(abort_log))) {
            LOG_WARN("CSFetcher: fail to deserialize abort", KR(ret), K(lsn));
          } else if (OB_FAIL(handle_abort_log_(tx_id))) {
            LOG_WARN("CSFetcher: fail to handle_abort_log", KR(ret), K(tx_id), K(lsn));
          }
          break;
        }
        case transaction::ObTxLogType::TX_ROLLBACK_TO_LOG: {
          transaction::ObTxRollbackToLog rollback_log;
          if (OB_FAIL(tx_log_block.deserialize_log_body(rollback_log))) {
            LOG_WARN("CSFetcher: fail to deserialize rollback_to", KR(ret), K(lsn));
          } else {
            if (OB_FAIL(handle_rollback_to_log_(tx_id,
                                                 rollback_log.get_from(),
                                                 rollback_log.get_to()))) {
              LOG_WARN("CSFetcher: fail to handle_rollback_to", KR(ret), K(tx_id), K(lsn));
            }
          }
          break;
        }
        default:
          break;
      }
    }

    // Advance progress tracking.
    current_lsn_ = lsn + log_entry.get_header_size() + log_entry.get_data_len();
    current_scn_ = scn;

    if (REACH_TIME_INTERVAL(CS_FETCHER_PROGRESS_LOG_INTERVAL_US)) {
      const palf::LSN min_dep = get_min_dep_lsn();
      LOG_INFO("CSFetcher: progress",
               K(current_lsn_), K(min_dep), K(current_scn_), K(total_tx_committed_),
               K(current_schema_version_), "inflight_tx_count", tx_info_.size());
    }
  }

  FLOG_INFO("CSFetcher: stopped", K(current_lsn_), K(current_scn_), K(total_tx_committed_));
}

}  // namespace share
}  // namespace oceanbase
